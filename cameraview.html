<!doctype html>
<!--
   ___                                       _
  / __\__ _ _ __ ___   ___ _ __ __ _  /\   /(_) _____      __
 / /  / _` | '_ ` _ \ / _ \ '__/ _` | \ \ / / |/ _ \ \ /\ / /
/ /__| (_| | | | | | |  __/ | | (_| |  \ V /| |  __/\ V  V /
\____/\__,_|_| |_| |_|\___|_|  \__,_|   \_/ |_|\___| \_/\_/


Usage:
  - Loads video definitions from config.json.
  - Append URL parameters to control the embedded video.
  - If URL parameters are present, plays a single video (see below).
  - If no parameters, cycles through all videos in config.json.

Parameters:
  ?video=sheep|reef|ospreys|jellyfish|fish|eagles|africa   (see config.json for available videos)
      Select a predefined video by name.
  ?code=<YouTubeVideoId>
      Override the video with any valid YouTube ID (takes precedence over ?video).
  ?mute=1|0
      1 (default) mutes to allow autoplay; 0 requests sound (autoplay may be blocked until user interacts).

Examples:
  page.html?video=reef
  page.html?video=ospreys&mute=0
  page.html?code=K380RGUXHsw&mute=1

Notes:
  Autoplay with sound can be blocked by browser policies; keep mute=1 for reliable autoplay.
  If you need sound immediately, user must interact (click/tap) before unmuting via the YouTube IFrame API.
-->

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Embedded Video</title>
    <meta name="referrer" content="strict-origin-when-cross-origin" />
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        background: #000;
      }
      iframe {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        border: 0;
      }
    </style>
  </head>
  <body>
    <iframe
      id="vidFrame"
      title="Video"
      allow="autoplay; fullscreen; picture-in-picture; encrypted-media"
      allowfullscreen
      referrerpolicy="strict-origin-when-cross-origin"
    >
    </iframe>
    <script>
      const configLocation = "config.json"; // Local file, adjust if needed
      const params = new URLSearchParams(location.search);
      const hasParams = params.has("video") || params.has("code");
      const muteParam = (params.get("mute") || "1").toLowerCase();
      const mute = muteParam === "0" || muteParam === "false" ? 0 : 1;
      const ytIdPattern = /^[A-Za-z0-9_-]{6,}$/;

      async function getConfig() {
        return await fetch(configLocation, { cache: "no-store" }).then((r) =>
          r.json(),
        );
      }

      function isActiveNow(active_hours) {
        if (!active_hours) return true; // If not set, always active
        const now = new Date();
        const [startH, startM] = active_hours.start.split(":").map(Number);
        const [endH, endM] = active_hours.end.split(":").map(Number);

        const start = new Date(now);
        start.setHours(startH, startM, 0, 0);
        const end = new Date(now);
        end.setHours(endH, endM, 0, 0);

        // Handle overnight windows (e.g. 22:00-06:00)
        if (end <= start) {
          return now >= start || now <= end;
        } else {
          return now >= start && now <= end;
        }
      }

      async function getConfigHash() {
        const configText = await fetch(configLocation, {
          cache: "no-store",
        }).then((r) => r.text());
        const hashBuffer = await crypto.subtle.digest(
          "SHA-256",
          new TextEncoder().encode(configText),
        );
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
      }

      function shuffle(array) {
        let currentIndex = array.length;
        while (currentIndex != 0) {
          let randomIndex = Math.floor(Math.random() * currentIndex);
          currentIndex--;
          [array[currentIndex], array[randomIndex]] = [
            array[randomIndex],
            array[currentIndex],
          ];
        }
      }

      const base = "https://www.youtube-nocookie.com/embed/";
      const query = (mute) => {
        return `?autoplay=1&mute=${mute}&controls=0&rel=0&modestbranding=1&playsinline=1&vq=hd1080`;
      };

      async function playSingleVideo(config) {
        const name = (params.get("video") || "").toLowerCase();
        const overrideCode = params.get("code");
        // Build map from config
        const map = {};
        for (const v of config.videos) {
          map[v.name.toLowerCase()] = v.youtube_id;
        }
        // Default to first video if not found
        let code = map[name] || config.videos[0].youtube_id;
        if (overrideCode && ytIdPattern.test(overrideCode)) code = overrideCode;

        document.getElementById("vidFrame").src = base + code + query(mute);

        if (mute === 0) {
          document.addEventListener(
            "click",
            () => {
              const f = document.getElementById("vidFrame");
              f.contentWindow?.postMessage(
                '{"event":"command","func":"unMute","args":""}',
                "*",
              );
            },
            { once: true },
          );
        }
      }

      async function playCycle(config) {
        const initialConfigHash = await getConfigHash();
        shuffle(config.videos);

        while (true) {
          for (const video of config.videos) {
            if (!isActiveNow(video.active_hours)) continue;
            const code = video.youtube_id;
            const duration = video.run_time;
            document.getElementById("vidFrame").src = base + code + query(1);
            await new Promise((resolve) =>
              setTimeout(resolve, duration * 60 * 1000),
            );
            const newConfigHash = await getConfigHash();
            if (newConfigHash !== initialConfigHash) {
              window.location.reload();
            }
          }
        }
      }

      // Main entry
      getConfig().then((config) => {
        if (hasParams) {
          playSingleVideo(config);
        } else {
          playCycle(config);
        }
      });
    </script>
  </body>
</html>
